import numpy as np
import wave
import writeobj
import audioanalysis
import cv2 as cv
import spectro

class AudioScape:

    def __init__(self, filepathin, chunkin=2**10):

        self.filepath = filepathin
        self.filename_out = self.filepath[:-4]

        self.chunk = chunkin

        """ open wavefile """
        self.wf = wave.open(filepathin, 'rb')

        # set properties
        self.bitdepth = self.wf.getsampwidth()
        self.samplerate = self.wf.getframerate()
        self.max_frequency = self.wf.getframerate() / 2.
        self.number_samples = self.wf.getnframes()
        self.number_channels = self.wf.getnchannels()

        """ check to see what the bitrate is, numpy does not support 24-bit"""
        if self.bitdepth == 1:
            self.dtype = np.uint8
        elif self.bitdepth == 2:
            self.dtype = np.int16
        elif self.bitdepth == 3:
            raise ValueError("24-bit audio not yet supported.")
        elif self.bitdepth == 4:
            self.dtype = np.float32

        self.buffer_size = self.chunk * self.number_channels

        self.width = int(self.number_samples / self.chunk)
        self.height = int(self.chunk / 2) + 1

        # generated by audio analysis
        self.fourier = np.empty((self.number_channels, self.width, self.height), dtype='float32')
        self.freq = []
        self.max_amp = 0

        self.vertices = None
        self.faces = []

        self.rsize = None

        # objects for data generation
        self.analysis = None
        self.spectrogram = None
        self.objexporter = None

    def close(self):
        del self.analysis
        del self.spectrogram
        del self.objexporter

    def analyze(self):
        self.analysis = audioanalysis.AudioAnalysis(self)
        self.analysis.analyze()
        #self.fourier = np.asfarray(self.fourier, 'float32')
        self.wf.close()

    def __generate_vertices(self):
        self.vertices = np.ndarray(shape=(len(self.fourier), len(self.freq), 2))
        num = 0
        for smpl in range(len(self.fourier)):
            for freq in range(len(self.freq)):
                self.vertices[smpl][freq][0] = self.freq[freq]
                self.vertices[smpl][freq][1] = self.fourier[smpl][freq]
                num += 1
        print("Vertices:", num)


    def __generate_faces(self):
        self.faces = []

        for smpl in range(len(self.fourier[0])-2):
            for freq in range(len(self.freq)-1):

                f1 = (smpl * len(self.freq)) + freq + 1
                f2 = ((smpl + 1) * len(self.freq) + freq + 1)
                f3 = f1 + 1
                f4 = f2 + 1
                self.faces.append((f1, f2, f3, f4))

    def __prepare_3d(self):
        self.__generate_vertices()
        self.__generate_faces()

    def smooth(self, mode="bilateral", params=(9, 75, 75)):
        if mode == "bilateral":
            if self.dtype != np.float32:
                self.fourier = self.fourier.astype(np.float32)
            for c in range(self.number_channels):
                self.fourier[c] = cv.bilateralFilter(self.fourier[c], params[0], params[1], params[2])

        self.filename_out += "_smoothed"
        self.max_amp = np.amax(self.fourier)

    def resize(self, sizeIn):
        # if number is float, will be interpreted as a factor
        self.rsize = sizeIn
        if type(sizeIn) is tuple:
            if type(sizeIn[0]) is float:
                sizeIn = (int(self.width * sizeIn[0]), sizeIn[1])
            if type(sizeIn[1]) is float:
                sizeIn = (sizeIn[0], int(self.height * sizeIn[1]))

            # temporary containers for resizing numpy array
            temp = np.ndarray((self.number_channels, sizeIn[0], sizeIn[1]), dtype=self.dtype)

            # opencv uses (height, width) format
            for c in range(self.number_channels):
                temp[c] = cv.resize(self.fourier[c], sizeIn[::-1])

            self.fourier = temp
            self.freq = cv.resize(self.freq, (1, sizeIn[1]))

            self.width = sizeIn[0]
            self.height = sizeIn[1]
            self.max_amp = np.amax(self.fourier)
        else:
            print("Could not resize, invalid tuple.")

    def trim(self, cutoff):
        if type(cutoff) is int:
            for i in range(self.height):
                if self.freq[i] >= cutoff:
                    cutoff = i
                    break
        if type(cutoff) is float:
            cutoff = int(cutoff * self.height)

        self.freq = self.freq[:cutoff]

        self.fourier = np.delete(self.fourier, np.s_[cutoff:], axis=2)

    def write_spectrogram(self, colorIn=False):
        self.auto_file_name()

        if not self.spectrogram:
            self.spectrogram = spectro.Spectro(self)
            self.spectrogram.create_spectrogram(color=colorIn)

        for c in range(self.number_channels):

            if c == 0:
                chn = "L"
            elif c == 1:
                chn = "R"
            else:
                chn = c

            self.spectrogram.save_spectrogram(channel=c, id=chn)

    def write_dualspectrogram(self, colorIn=False):
        if self.number_channels != 2:
            print("Not a stereo file. Image writing aborted.")
            return

        self.auto_file_name()

        if not self.spectrogram:
            self.spectrogram = spectro.Spectro(self)
            self.spectrogram.create_spectrogram(color=colorIn)

        self.spectrogram.im[0] = np.vstack((self.spectrogram.im[0], np.flipud(self.spectrogram.im[1])))
        self.spectrogram.save_spectrogram(channel=0, id="stereo")

    def auto_file_name(self):
        self.filename_out += "_{}".format(self.chunk)
        if self.rsize:
            self.filename_out += "_{}x{}".format(self.rsize[0], self.rsize[1])