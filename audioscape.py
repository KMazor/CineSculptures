import numpy as np
import wave
import writeobj
import audioanalysis
import cv2 as cv
import spectro

class AudioScape:

    def __init__(self, filepathin, chunkin=2**10):

        self.filepath = filepathin
        self.filename_out = self.filepath[:-4]

        self.chunk = chunkin

        """ open wavefile """
        self.wf = wave.open(filepathin, 'rb')

        # set properties
        self.bitdepth = self.wf.getsampwidth()
        self.samplerate = self.wf.getframerate()
        self.max_frequency = self.wf.getframerate() / 2.
        self.number_samples = self.wf.getnframes()

        self.width = int(self.number_samples / self.chunk)
        self.height = int(self.chunk / 2) + 1

        # generated by audio analysis
        self.fourier = np.empty((self.width, self.height), dtype='float32')
        self.freq = []

        self.vertices = None
        self.faces = []

        self.rsize = None

        # objects for data generation
        self.analysis = None
        self.spectrogram = None
        self.objexporter = None

    def close(self):
        self.wf.close()
        del self.analysis
        del self.spectrogram
        del self.objexporter

    def analyze(self):
        self.analysis = audioanalysis.AudioAnalysis(self)
        self.analysis.analyze()
        self.fourier = np.asfarray(self.fourier, 'float32')

    def __generate_vertices(self):
        self.vertices = np.ndarray(shape=(len(self.fourier), len(self.freq), 2))
        num = 0
        for smpl in range(len(self.fourier)):
            for freq in range(len(self.freq)):
                self.vertices[smpl][freq][0] = self.freq[freq]
                self.vertices[smpl][freq][1] = self.fourier[smpl][freq]
                num += 1
        print("Vertices:", num)


    def __generate_faces(self):
        self.faces = []

        for smpl in range(len(self.fourier)-2):
            for freq in range(len(self.freq)-1):

                f1 = (smpl * len(self.freq)) + freq + 1
                f2 = ((smpl + 1) * len(self.freq) + freq + 1)
                f3 = f1 + 1
                f4 = f2 + 1
                self.faces.append((f1, f2, f3, f4))

    def __prepare_3d(self):
        self.__generate_vertices()
        self.__generate_faces()

    def smooth(self, mode="bilateral", params=(9, 75, 75)):
        if mode == "bilateral":
            self.fourier = cv.bilateralFilter(self.fourier, params[0], params[1], params[2])

        self.filename_out += "_smoothed"

    def resize(self, sizeIn):
        # if number is float, will be interpreted as a factor
        self.rsize = sizeIn
        if type(sizeIn) is tuple:
            if type(sizeIn[0]) is float:
                sizeIn = (int(len(self.fourier) * sizeIn[0]), sizeIn[1])
            if type(sizeIn[1]) is float:
                sizeIn = (sizeIn[0], int(len(self.freq) * sizeIn[1]))

            # opencv uses (height, width) format
            self.fourier = cv.resize(self.fourier, sizeIn[::-1])
            self.freq = cv.resize(self.freq, (1, sizeIn[1]))
        else:
            print("Could not resize, invalid tuple.")

    def trim(self, cutoff):
        if type(cutoff) is int:
            for i in range(self.height):
                if self.freq[i] >= cutoff:
                    cutoff = i
                    break
        if type(cutoff) is float:
            cutoff = int(cutoff * self.height)

        self.freq = self.freq[:cutoff]

        self.fourier = np.delete(self.fourier, np.s_[cutoff:], axis=1)

    def write_spectrogram(self, sizeIn="", colorIn=False):
        self.auto_file_name()
        self.spectrogram = spectro.Spectro(self)
        self.spectrogram.create_spectrogram(size=sizeIn, color=colorIn)
        self.spectrogram.save_spectrogram()


    def write_obj(self):
        self.auto_file_name()
        self.__prepare_3d()

        objexporter = writeobj.WriteOBJ(self)
        objexporter.write(self.filename_out + ".obj")

    def auto_file_name(self):
        self.filename_out += "_{}".format(self.chunk)
        if self.rsize:
            self.filename_out += "_{}x{}".format(self.rsize[0], self.rsize[1])